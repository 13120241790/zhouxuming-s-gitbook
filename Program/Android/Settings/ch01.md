# Android System Settings Preference Hook Hide

![](/Program/img/Screenshot_20251216_161234.png)

我们知道在 settings 中大部分的组件都是由 Preference 组成的，但是实际的 settings 二次开发中，我们有很多的隐藏某个条目的需求，那么我们一般如隐藏这些条目呢？

方法有三：

第一种方式是通过对每个 Preference 或者 PreferenceCategory 直接设置 isPreferenceVisible 标签属性。

第二种方式是通过 Preference 或者 PreferenceCategory 实现了 Controller 的话可以在实现的代码中做出如下调整来决定要不要展示这个  Preference 或者 PreferenceCategory，示例如下:

```java
    @Override
    public int getAvailabilityStatus() {
        if (mChildren == null || mChildren.isEmpty()) {
            return UNSUPPORTED_ON_DEVICE;
        }
        // Category is available if any child is available
        for (AbstractPreferenceController controller : mChildren) {
            if (controller.isAvailable()) {
                return AVAILABLE;
            }
        }
        return CONDITIONALLY_UNAVAILABLE;
    }
```

以上两种方式均只是对单一的 Preference 或者 PreferenceCategory 进行处理，如果有大批量的 Preference 或者 PreferenceCategory 需要进行隐藏，用上述两种方式未免显得有些蠢笨，而且代码修改会散步到整个项目各处都是，有没有更完美的处理方法？有的！

我们只需要找到一个关键的 hook 点，然后对需要隐藏的 Preference 或者 PreferenceCategory 唯一标识符 key 统一到一个黑名单中做集中处理即可满足大批量集中管理的需求，具体实现如下：

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <array name="black_list">
        //Add the preference key that needs to be hidden
<!--        <item>top_level_tether</item>-->
        <item>top_level_wallpaper</item>
        <item>top_level_game_assistant</item>
        <item>top_level_learn</item>
        <item>top_level_ai</item>
        <item>top_level_keyboard</item>
        <item>top_level_advanced</item>
   </array>
</resources>
```

先建一个 resource 资源文件，用于集中管理 keys

```java
    public static List<String> getBlackList() {
        if (blackList.isEmpty()) {
            String[] keys = SettingsApplication.getInstance().getResources().getStringArray(com.android.settingslib.R.array.black_list);
            blackList.addAll(Arrays.asList(keys));
        }
        return blackList;
    }
```

然后我们在代码中拿到这个列表的内存引用，分别在 PreferenceControllerListHelper 的 getPreferenceControllersFromXml 方法中插入 hook

```java
    public static List<BasePreferenceController> getPreferenceControllersFromXml(Context context,
            @XmlRes int xmlResId) {
        final List<BasePreferenceController> controllers = new ArrayList<>();
        List<Bundle> preferenceMetadata;
        try {
            preferenceMetadata = PreferenceXmlParserUtils.extractMetadata(context, xmlResId,
                    MetadataFlag.FLAG_NEED_KEY | MetadataFlag.FLAG_NEED_PREF_CONTROLLER
                            | MetadataFlag.FLAG_INCLUDE_PREF_SCREEN  | MetadataFlag.FLAG_FOR_WORK);
        } catch (IOException | XmlPullParserException e) {
            Log.e(TAG, "Failed to parse preference xml for getting controllers", e);
            return controllers;
        }

        for (Bundle metadata : preferenceMetadata) {
            final String controllerName = metadata.getString(METADATA_CONTROLLER);
            if (TextUtils.isEmpty(controllerName)) {
                continue;
            }
            BasePreferenceController controller;
            try {
                controller = BasePreferenceController.createInstance(context, controllerName);
            } catch (IllegalStateException e) {
                Log.d(TAG, "Could not find Context-only controller for pref: " + controllerName);
                final String key = metadata.getString(METADATA_KEY);
                final boolean isWorkProfile = metadata.getBoolean(METADATA_FOR_WORK, false);
                if (TextUtils.isEmpty(key)) {
                    Log.w(TAG, "Controller requires key but it's not defined in xml: "
                            + controllerName);
                    continue;
                }
                List<String> blackList = Utils.getBlackList();
                if (!blackList.isEmpty()) {
                    if (blackList.contains(key)) {
                        Log.w(TAG, "Controller requires key is in the blacklist, key: " + key + " ,className: "
                                + controllerName);
                        //避免创建无效controller浪费资源
                        continue;
                    }
                }
                try {
                    controller = BasePreferenceController.createInstance(context, controllerName,
                            key, isWorkProfile);
                } catch (IllegalStateException e2) {
                    Log.w(TAG, "Cannot instantiate controller from reflection: " + controllerName);
                    continue;
                }
            }
            controllers.add(controller);
        }
        return controllers;
    }}
```

还有一个 hook 点是 DashboardFragment 的如下方法中：

```java
    public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
        checkUiBlocker(mControllers);
        refreshAllPreferences(getLogTag());
        List<String> blackList = Utils.getBlackList();
        for (String key : blackList) {
            Preference container = findPreference(key);
            if (container != null) {
                container.setVisible(false);
            }
        }
        mControllers.stream()
                .filter(controller -> !blackList.contains(controller.getPreferenceKey()))
                .map(controller -> (Preference) findPreference(controller.getPreferenceKey()))
                .filter(Objects::nonNull)
                .forEach(preference -> {
                    // Give all controllers a chance to handle click.
                    preference.getExtras().putInt(CATEGORY, getMetricsCategory());
                });
    }
```

这样我们就可以对批量管理的 key list 看隐藏效果了。

但是此处还有一个漏洞，如果在 settings 的搜索页面去搜被隐藏的 item 还是可能被搜出来，这样就没有达到我们搜索的目的，所以在这个场景我们也是需要做 hook 的统一管理，创建 resource 的过程和上文一样这里我们直接上关键代码 SearchResultGroupManager

```java
   private List<SearchResult> groupDataList(List<? extends SearchResult> resultList) {
        sMenuKeyList.forEach(s -> mTopLevelGroupMap.put(s, new ArrayList<>()));

        Iterator<? extends SearchResult> it = resultList.iterator();
        while (it.hasNext()) {
            SearchResult result = (SearchResult) it.next();
            if (TextUtils.isEmpty(result.dataKey) || TextUtils.isEmpty(result.title)) {
                it.remove();
                continue;
            }

            Intent payloadIntent = result.payload.getIntent();
            if (payloadIntent == null) {
                it.remove();
                continue;
            }

            List<SearchResult> subResultList;
            String highlightMenuKey = payloadIntent.getStringExtra(EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);
            if (!TextUtils.isEmpty(highlightMenuKey)) {

                logD("TopLevel dataKey: " + result.dataKey
                        + " title:" + result.title
                        + " highlightMenuKey:" + highlightMenuKey);

                subResultList = mTopLevelGroupMap.get(highlightMenuKey);
                if (subResultList != null) {
                    subResultList.add(result);
                    mTopLevelGroupMap.put(highlightMenuKey, subResultList);
                    continue;
                }

            }

            //no top_level_menu_key
            logD("No top level group dataKey: " + result.dataKey
                    + " title:" + result.title);
            subResultList = mTopLevelGroupMap.get(TOP_LEVEL_PLACEHOLDER);
            if (subResultList != null) {
                subResultList.add(result);
                mTopLevelGroupMap.put(TOP_LEVEL_PLACEHOLDER, subResultList);
            }
          
            if (CsdkUtils.INSTANCE.isApplicationPermissionPageDisallow()) {
                if (result.dataKey.contains("com.google.android.permissioncontroller")
                        || "privacy_manage_perms".contains(result.dataKey)) {
                    it.remove();
                    continue;
                }
            }
            if (CsdkUtils.INSTANCE.isSpecialAccessPermissionPage()) {
                if ("key_special_access_page".contains(result.dataKey)) {
                    it.remove();
                    continue;
                }
            }
           
        }

        List<SearchResult> results = new ArrayList<>();
        String[] stringArray = mContext.getResources().getStringArray(com.android.settingslib.R.array.filter_list);
        List<String> list = Arrays.asList(stringArray);
        for (String menuKey : sMenuKeyList) {
            if (!list.contains(menuKey)) {
                List<SearchResult> subResults = mTopLevelGroupMap.get(menuKey);
                if (subResults != null && !subResults.isEmpty()) {
                    Iterator<SearchResult> iterator = subResults.iterator();
                    while (iterator.hasNext()){
                        SearchResult result = iterator.next();
                        if (list.contains(result.dataKey)) {
                            Log.e(TAG,"group menuKey :" + menuKey + " remove sub result : " + result);
                            iterator.remove();
                        } else {
                            Log.e(TAG,"group menuKey :" + menuKey + " sub result : " + result);
                        }
                    }
                    if (!subResults.isEmpty()) {
                        results.addAll(subResults);
                        SearchResult groupFirstResult = subResults.get(0);
                        if (groupFirstResult != null) {
                            groupFirstResult.setIsGroupFirst(true);
                            groupFirstResult.icon = mTopLevelIconCollectors.getIcon(menuKey);
                        }
                        // add line search result
                        results.add(new SearchResult.Builder()
                                .setDataKey(LINE_DATA_KEY)
                                .setTitle(LINE_DATA_TITLE)
                                .setPayload(new LineQueryPayload())
                                .build());
                    }
                }
            }
        }


        return results;
    }
```

至此所有的隐藏方式介绍完毕

