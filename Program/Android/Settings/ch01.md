# Android System Settings Preference Hook Hide![](/Program/img/Screenshot_20251216_161234.png)

我们知道在 settings 中大部分的组件都是由 Preference 组成的，但是实际的 settings 二次开发中，我们有很多的隐藏某个条目的需求，那么我们一般如隐藏这些条目呢？



方法有三：

第一种方式是通过对每个 Preference 或者 PreferenceCategory 直接设置 isPreferenceVisible 标签属性。

第二种方式是通过 Preference 或者 PreferenceCategory 实现了 Controller 的话可以在实现的代码中做出如下调整来决定要不要展示这个  Preference 或者 PreferenceCategory，示例如下:

```java
    @Override
    public int getAvailabilityStatus() {
        if (mChildren == null || mChildren.isEmpty()) {
            return UNSUPPORTED_ON_DEVICE;
        }
        // Category is available if any child is available
        for (AbstractPreferenceController controller : mChildren) {
            if (controller.isAvailable()) {
                return AVAILABLE;
            }
        }
        return CONDITIONALLY_UNAVAILABLE;
    }
```

以上两种方式均只是对单一的 Preference 或者 PreferenceCategory 进行处理，如果有大批量的 Preference 或者 PreferenceCategory 需要进行隐藏，用上述两种方式未免显得有些蠢笨，而且代码修改会散步到整个项目各处都是，有没有更完美的处理方法？有的！



我们只需要找到一个关键的 hook 点，然后对需要隐藏的 Preference 或者 PreferenceCategory 唯一标识符 key 统一到一个黑名单中做集中处理即可满足大批量集中管理的需求，具体实现如下：

```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <array name="black_list">
        //Add the preference key that needs to be hidden
        <item>top_level_lenovo_account</item>
<!--        <item>top_level_tether</item>-->
        <item>top_level_wallpaper</item>
        <item>top_level_game_assistant</item>
        <item>top_level_learn</item>
        <item>top_level_ai</item>
        <item>top_level_keyboard</item>
        <item>top_level_advanced</item>
   </array>
</resources>        
```

先建一个 resource 资源文件，用于集中管理 keys 

```java
    public static List<String> getBlackList() {
        if (blackList.isEmpty()) {
            String[] keys = SettingsApplication.getInstance().getResources().getStringArray(com.android.settingslib.R.array.black_list);
            blackList.addAll(Arrays.asList(keys));
        }
        return blackList;
    }
```

然后我们在代码中拿到这个列表的内存引用，分别在 PreferenceControllerListHelper 的 getPreferenceControllersFromXml 方法中插入 hook 

```java
    public static List<BasePreferenceController> getPreferenceControllersFromXml(Context context,
            @XmlRes int xmlResId) {
        final List<BasePreferenceController> controllers = new ArrayList<>();
        List<Bundle> preferenceMetadata;
        try {
            preferenceMetadata = PreferenceXmlParserUtils.extractMetadata(context, xmlResId,
                    MetadataFlag.FLAG_NEED_KEY | MetadataFlag.FLAG_NEED_PREF_CONTROLLER
                            | MetadataFlag.FLAG_INCLUDE_PREF_SCREEN  | MetadataFlag.FLAG_FOR_WORK);
        } catch (IOException | XmlPullParserException e) {
            Log.e(TAG, "Failed to parse preference xml for getting controllers", e);
            return controllers;
        }

        for (Bundle metadata : preferenceMetadata) {
            final String controllerName = metadata.getString(METADATA_CONTROLLER);
            if (TextUtils.isEmpty(controllerName)) {
                continue;
            }
            BasePreferenceController controller;
            try {
                controller = BasePreferenceController.createInstance(context, controllerName);
            } catch (IllegalStateException e) {
                Log.d(TAG, "Could not find Context-only controller for pref: " + controllerName);
                final String key = metadata.getString(METADATA_KEY);
                final boolean isWorkProfile = metadata.getBoolean(METADATA_FOR_WORK, false);
                if (TextUtils.isEmpty(key)) {
                    Log.w(TAG, "Controller requires key but it's not defined in xml: "
                            + controllerName);
                    continue;
                }
                List<String> blackList = Utils.getBlackList();
                if (!blackList.isEmpty()) {
                    if (blackList.contains(key)) {
                        Log.w(TAG, "Controller requires key is in the blacklist, key: " + key + " ,className: "
                                + controllerName);
                        //避免创建无效controller浪费资源
                        continue;
                    }
                }
                try {
                    controller = BasePreferenceController.createInstance(context, controllerName,
                            key, isWorkProfile);
                } catch (IllegalStateException e2) {
                    Log.w(TAG, "Cannot instantiate controller from reflection: " + controllerName);
                    continue;
                }
            }
            controllers.add(controller);
        }
        return controllers;
    }}
```

还有一个 hook 点是 DashboardFragment 的如下方法中：

```java
    public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
        checkUiBlocker(mControllers);
        refreshAllPreferences(getLogTag());
        List<String> blackList = Utils.getBlackList();
        for (String key : blackList) {
            Preference container = findPreference(key);
            if (container != null) {
                container.setVisible(false);
            }
        }
        mControllers.stream()
                .filter(controller -> !blackList.contains(controller.getPreferenceKey()))
                .map(controller -> (Preference) findPreference(controller.getPreferenceKey()))
                .filter(Objects::nonNull)
                .forEach(preference -> {
                    // Give all controllers a chance to handle click.
                    preference.getExtras().putInt(CATEGORY, getMetricsCategory());
                });
    }
```

这样我们就可以对批量管理的 key list 看隐藏效果了。



但是此处还有一个漏洞，如果在 settings 的搜



